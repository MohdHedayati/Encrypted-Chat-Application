{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Secure Chat App Documentation","text":"<p>Welcome to the documentation for the Secure Chat App, this is a comprehensive guide covering the project's architecture, security features, and implementation details.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Project Overview</li> <li>WebSockets</li> <li>Cryptography Algorithms<ul> <li>RSA</li> <li>AES</li> </ul> </li> <li>Hybrid Encryption</li> <li>Mini Projects</li> <li>Future Scope</li> <li>Conclusion</li> </ol>"},{"location":"conclusion/","title":"Conclusion","text":"<p>The successful implementation of this real-time chat application marks the completion of a critical foundational phase, centering on security, integrity, and performance. By leveraging the Web Crypto API, we established true End-to-End Encryption (E2EE), utilizing RSA for secure key establishment and AES for high-throughput symmetric message encryption. This architectural decision ensures that message content remains private and inaccessible to any intermediary, fulfilling the most stringent requirements for user data protection.</p> <p>Furthermore, the choice of WebSockets, secured by TLS (Transport Layer Security) operating over TCP, guarantees a reliable, full-duplex, and low-latency channel for data exchange. This stack provides the necessary speed for real-time interaction while ensuring all data in transit is cryptographically protected against eavesdropping. The resulting platform is a high-assurance, performant, and reliable mechanism for secure one-to-one messaging.</p> <p>Looking ahead, this robust security framework provides the perfect architecture for expansion. The future scope, focused on introducing Group Chats, integrating Image Support, executing essential UI/UX improvements, and planning for large-scale Deployment, will directly benefit from the existing secure foundation. Specifically, the challenge of extending E2EE to multi-user group environments, securely managing media uploads, and maintaining performance under load will be met by adapting the proven RSA/AES key management and WebSocket infrastructure. The project is thus positioned to evolve from a secure proof-of-concept into a scalable, feature-rich, and consumer-ready communication platform.</p>"},{"location":"future_scope/","title":"Future Scope and Roadmap","text":"<p>This roadmap outlines the major planned features and improvements for the chat application, expanding upon the existing one-to-one chat functionality.</p>"},{"location":"future_scope/#1-feature-expansion-group-chats","title":"1. Feature Expansion: Group Chats","text":"<p>The immediate priority is introducing multi-user conversations through Group Chats.</p> <ul> <li> <p>Group Creation:</p> <ul> <li>Allow users to create groups, define names, and add optional descriptions/icons. </li> </ul> </li> <li> <p>Member Management:</p> <ul> <li>Implement tools for group admins (creators) to add, remove, and manage administrative roles for members. </li> </ul> </li> <li> <p>Real-Time Group Messaging:</p> <ul> <li>Enable seamless, real-time message sending and receiving within all group threads. </li> </ul> </li> <li> <p>Notifications:</p> <ul> <li>Ensure users receive appropriate and timely notifications for new messages in groups they belong to.</li> </ul> </li> </ul>"},{"location":"future_scope/#2-rich-media-support-image-sharing","title":"2. Rich Media Support (Image Sharing)","text":"<p>This includes adding support for sharing image files securely in both one-to-one and group chats.</p> <ul> <li> <p>Image Upload:</p> <ul> <li>Allow users to select and upload images directly from their devices. </li> </ul> </li> <li> <p>Secure Storage &amp; Retrieval:</p> <ul> <li>Store images securely and generate time-limited, authenticated URLs for display. </li> </ul> </li> <li> <p>In-Chat Preview:</p> <ul> <li>Display a clear, thumbnail-sized preview of the image within the chat component, with an option to view the full-size version.</li> </ul> </li> </ul>"},{"location":"future_scope/#3-user-interface-ui-and-experience-ux-improvements","title":"3. User Interface (UI) and Experience (UX) Improvements","text":"<p>Enhancing the application's look, responsiveness, and overall usability.</p> <ul> <li> <p>Responsive Design:</p> <ul> <li>Refactor styling (using Tailwind CSS) to ensure the app looks and works great on all screen sizes (mobile, tablet, desktop).</li> </ul> </li> <li> <p>Theming:</p> <ul> <li>Implement a light/dark mode toggle based on user preference or system settings.</li> </ul> </li> <li> <p>Presence Indicators:</p> <ul> <li>Add \"typing...\" indicators and last-seen timestamps to give users better context in conversations. </li> </ul> </li> <li> <p>Search Functionality:</p> <ul> <li>Introduce a search bar to quickly find contacts, group chats, and easily search message history. </li> </ul> </li> </ul>"},{"location":"future_scope/#4-deployment-and-scalability","title":"4. Deployment and Scalability","text":"<p>Setting up a robust infrastructure for testing, stability, and future growth.</p> <ul> <li> <p>Staging Environment:</p> <ul> <li>Set up a parallel, non-production environment for comprehensive testing of new features before they go live.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>Review and optimize data fetching logic, particularly for loading long message histories and media. </li> </ul> </li> <li> <p>Domain &amp; Hosting:</p> <ul> <li>Deploy the final application to a reliable hosting provider under a custom domain. </li> </ul> </li> </ul>"},{"location":"hybrid_encryption/","title":"Hybrid Encryption","text":"<p>Now that we understand the fundamentals of Asymmetric (RSA) and Symmetric (AES) encryption algorithms, we can proceed with their implementation using the browser's built-in Web Crypto API.</p> <p>Let us first understand the need for Hybrid Encryption </p> <ul> <li> <p>Key Distribution Challenge: Symmetric AES requires both users to have the same secret key. Since users can't meet to exchange it, RSA is necessary to securely transmit that secret key across the internet.</p> </li> <li> <p>Performance Optimisation: The slow, computation-heavy RSA is used only once for the initial key delivery, ensuring the fast, efficient AES is reserved for the bulk of high-speed message transfer.</p> </li> <li> <p>Speed for Data (AES Strength): AES is vastly faster than RSA. This speed is essential for quickly encrypting the large volume of data (every chat message) required for a responsive user experience.</p> </li> <li> <p>Complete Confidentiality: Using the RSA-secured channel to deliver the AES key guarantees that the Session Key is known only to the two communicating parties, achieving true end-to-end confidentiality. </p> </li> <li> <p>Symmetric Encryption: The sender first uses a fast common Key (AES) to encrypt the Plaintext Message into Ciphertext.</p> </li> <li> <p>Asymmetric Key Transport: The sender then uses the recipient's Public Key (RSA) to securely encrypt and transport that small common Key alongside the ciphertext.</p> </li> <li> <p>Two-Step Decryption: The recipient first uses their secret Private Key (RSA) to retrieve the Session Key, which is then used to decrypt the Ciphertext back into the original message.</p> </li> </ul> <p>Web Cypto API's has functions that do this job for us : 1. Generate keys (Sender side)</p> <pre><code>export async function generateRSAKeyPair() {  \n    try {  \n        const keyPair = await window.crypto.subtle.generateKey(  \n            {  \n                name: \"RSA-OAEP\",  \n                modulusLength: 2048,  // Key size  \n                publicExponent: new Uint8Array([1, 0, 1]),  \n                hash: \"SHA-256\"  \n            },  \n            true,  // Public key is extractable  \n            [\"encrypt\", \"decrypt\"]  // Key usages  \n        );  \n\n        return keyPair;  // publicKey,privateKey  \n    } catch (error) {  \n        console.error(\"Error generating RSA key pair:\", error);  \n        throw error;  \n    }  \n}\n</code></pre> <ul> <li> <p>This function gives us the KeyPair(Private and Public key) by just specifying name of the mode (here RSA-OAEP) and we simply return it.</p> </li> <li> <p>Encrypt AES key using RSA public key(Sender side)</p> </li> </ul> <pre><code>export async function wrapAESKeyWithRSA(aesKey, receiverPublicKey) {  \n    try {  \n        // Export AES key to raw format  \n        const aesKeyRaw = await window.crypto.subtle.exportKey(\"raw\", aesKey);  \n\n        // Encrypt with RSA public key  \n        const wrappedKey = await window.crypto.subtle.encrypt(  \n            {  \n                name: \"RSA-OAEP\"  \n            },  \n            receiverPublicKey,  \n            aesKeyRaw  \n        );  \n\n        return arrayBufferToBase64(wrappedKey);  \n    } catch (error) {  \n        console.error(\"Error wrapping AES key:\", error);  \n        throw error;  \n    }  \n}\n</code></pre> <ul> <li> <p>For encrypting the AES Key we firstly convert it to Raw format(binary) and then encrypt it with receiver's Public Key.</p> </li> <li> <p>Decrypt AES key using RSA private key(Receiver side)</p> <ul> <li>This occurs after the message has been routed by the server to the receiver.</li> </ul> </li> </ul> <pre><code>export async function unwrapAESKeyWithRSA(wrappedKeyBase64, privateKey) {  \n    try {  \n        const wrappedKey = base64ToArrayBuffer(wrappedKeyBase64);  \n        const aesKeyRawBuffer = await window.crypto.subtle.decrypt(  \n            {  \n                name: \"RSA-OAEP\"  \n            },  \n            privateKey,  \n            wrappedKey  \n        );  \n            // After decrypting,must import the raw buffer back into a CryptoKey              object  \n        const aesKey = await window.crypto.subtle.importKey(  \n            \"raw\", // Format of the key to import  \n            aesKeyRawBuffer,  \n            {  \n                name: \"AES-GCM\",  \n                length: 256  \n            },  \n            true, // Extractable  \n            [\"encrypt\", \"decrypt\"]  \n        );  \n\n        return aesKey;  \n    } catch (error) {  \n        console.error(\"Error unwrapping AES key:\", error);  \n        throw error;  \n    }  \n}\n</code></pre> <ul> <li>Encrypted AES key is base64 encoded as needed for transmission and after transforming  it into Raw format, we decrypt it using Receiver's Private Key and finally we convert it into CryptoKey format using the Import Key function.</li> </ul>"},{"location":"hybrid_encryption/#we-saw-key-generation-encryption-and-decryption-for-rsa-similarly-we-can-do-for-aes","title":"We saw Key Generation, Encryption and Decryption for RSA  similarly we can do for AES.","text":""},{"location":"overview/","title":"Project Overview","text":""},{"location":"overview/#introduction","title":"Introduction","text":"<p>This document provides a technical overview of the Secure Chat Application, a real-time messaging platform designed with a primary focus on security and privacy. The application ensures that all communications are confidential and secure through a robust, multi-layered encryption strategy.</p> <p>The project is built using a modern technology stack, with React for the frontend client and Spring Boot for the backend server. Real-time, bidirectional communication is achieved using WebSockets.</p>"},{"location":"overview/#core-technologies","title":"Core Technologies","text":"<ul> <li>Frontend: React</li> <li>Backend: Spring Boot</li> <li>Real-Time Communication: WebSockets</li> <li>Security:<ul> <li>Hybrid Encryption (RSA + AES) for End-to-End Encryption</li> <li>TLS/SSL for Transport Layer Security</li> </ul> </li> </ul>"},{"location":"overview/#key-features","title":"Key Features","text":""},{"location":"overview/#1-end-to-end-encryption-e2ee","title":"1. End-to-End Encryption (E2EE)","text":"<p>The application's core security feature is its implementation of End-to-End Encryption. This ensures that a message is encrypted on the sender's device and can only be decrypted by the intended recipient's device. The server, or any potential eavesdropper, cannot read the message content.</p>"},{"location":"overview/#2-hybrid-encryption-model","title":"2. Hybrid Encryption Model","text":"<p>To achieve robust and efficient E2EE, the application uses a hybrid encryption model that combines the strengths of both asymmetric (RSA) and symmetric (AES) cryptography.</p> <ul> <li>RSA (Asymmetric Encryption): Used to securely exchange symmetric keys between users. Each user has a public/private key pair. The public key is used to encrypt a one-time session key, which can only be decrypted by the recipient's corresponding private key.</li> <li>AES (Symmetric Encryption): Used for the actual encryption of messages. AES is much faster than RSA for encrypting large amounts of data. A new, unique AES session key is generated for each conversation, exchanged securely using RSA, and then used to encrypt all messages within that session.</li> </ul>"},{"location":"overview/#3-transport-layer-security-tls","title":"3. Transport Layer Security (TLS)","text":"<p>In addition to E2EE for message content, all communication between the client and the server is wrapped in a TLS (Transport Layer Security) tunnel. This encrypts the entire data stream, protecting message metadata and preventing man-in-the-middle (MITM) attacks between the client and the server.</p>"},{"location":"overview/#4-real-time-communication","title":"4. Real-Time Communication","text":"<p>The use of WebSockets provides a persistent, full-duplex communication channel between the client and the server. This allows for the instantaneous delivery of messages and presence status updates (e.g., typing indicators) without the overhead of traditional HTTP polling, creating a seamless and responsive user experience.</p>"},{"location":"websockets/","title":"WebSockets in the Secure Chat App","text":"<p>WebSockets are a foundational technology for this project, enabling the real-time, bidirectional communication that is essential for a modern chat application.</p>"},{"location":"websockets/#what-are-websockets","title":"What are WebSockets?","text":"<p>A WebSocket is a communication protocol that provides a full-duplex, persistent connection between a client (like a user's browser) and a server.</p> <p>Think of traditional HTTP as sending letters. The client sends a request (a letter), and the server sends a response (a letter back). The conversation is a series of separate exchanges. A WebSocket, on the other hand, is like a telephone call. The client \"calls\" the server once to open a connection, and that line stays open, allowing both sides to talk freely and instantly until one of them hangs up.</p>"},{"location":"websockets/#why-use-websockets-for-a-chat-application","title":"Why Use WebSockets for a Chat Application?","text":"<p>Using WebSockets is critical for creating a responsive and seamless user experience.</p> <ul> <li>Low Latency: As soon as a message is sent, it's pushed through the open connection to the recipient almost instantly. There's no need for the client to constantly ask the server, \"Are there any new messages?\"</li> <li>Full-Duplex Communication: Data can flow in both directions at the same time. The server can push messages to the client at any moment, which is perfect for receiving new messages, typing indicators, and presence updates (e.g., online status).</li> <li>Efficiency: After the initial connection (the \"handshake\"), the data frames sent back and forth have very little overhead compared to the bulky headers of HTTP requests. This saves bandwidth and improves performance.</li> </ul>"},{"location":"websockets/#securing-websockets-wss","title":"Securing WebSockets (WSS)","text":"<p>Given the application's focus on security, all WebSocket connections are established using the Secure WebSocket protocol (<code>wss://</code>).</p> <p><code>WSS</code> is to <code>WS</code> what <code>HTTPS</code> is to <code>HTTP</code>. It means that the WebSocket connection is layered on top of a Transport Layer Security (TLS) tunnel. The initial handshake is done over HTTPS, and all subsequent WebSocket data is automatically encrypted by the same TLS layer that secures the rest of the application's traffic.</p> <p>This prevents eavesdropping and man-in-the-middle (MITM) attacks on the communication channel between the client and the server. It secures the \"pipe,\" while the End-to-End Encryption (E2EE) secures the message inside the pipe.</p>"},{"location":"websockets/#implementation-in-this-project","title":"Implementation in This Project","text":"<p>In our architecture, the Spring Boot backend exposes a WebSocket endpoint. The React frontend client initiates a connection to this endpoint. Once the secure handshake is complete, this persistent connection is used to:</p> <ol> <li>Send new chat messages from the client to the server.</li> <li>Push incoming messages from the server to the correct recipient client in real time.</li> <li>Transmit real-time events like typing notifications.</li> </ol>"},{"location":"cryptography_algorithms/","title":"Overview","text":""},{"location":"cryptography_algorithms/#what-is-cryptography","title":"What is Cryptography","text":"<p>Cryptography is the practice and study of techniques for secure communication in the presence of adversarial behaviour. It involves transforming readable data (plain text) into an unreadable format (cipher text) and back again</p> <p>Our Chat App focuses on user's Privacy and confidentiality of Data, for that we use Two Cryptography Algorithms.  - RSA (Rivest-Shamir-Adleman) - AES (Advance Encryption Standard)</p>"},{"location":"cryptography_algorithms/#need-for-cryptography","title":"Need for Cryptography","text":"<p>In a chat application, cryptography is essential to guarantee:</p> <ul> <li>Confidentiality<ul> <li>Messages are kept secret. Only the intended recipient can read the content, even if a third party (like the server or an attacker) intercepts the data.</li> </ul> </li> <li>Integrity<ul> <li>Ensures the message hasn't been altered during transmission.</li> </ul> </li> <li>Authentication<ul> <li>Verifies that the sender is who they claim to be.</li> </ul> </li> </ul>"},{"location":"cryptography_algorithms/#implementation","title":"Implementation","text":""},{"location":"cryptography_algorithms/#1-rsa","title":"1. [[RSA]]","text":"<ul> <li>Rivest-Shamir-Adleman (RSA) Algorithm is an * asymmetric or * public-key cryptography algorithm which means it works with two different keys:  Public Key and * Private Key.</li> </ul>"},{"location":"cryptography_algorithms/#2-aes","title":"2. [[AES]]","text":"<ul> <li>Advanced Encryption Standard (AES) is an symmetric cryptography*  algorithm used to secure data using a single key for both Encryption and Decryption.</li> </ul>"},{"location":"cryptography_algorithms/#web-crypto-api","title":"Web Crypto API","text":"<ul> <li>There are several libraries and frameworks available in Java for implementing cryptography, such as the Java Cryptography Architecture (JCA), which provides high-level APIs that abstract the low-level details of algorithms like AES and RSA.  </li> <li>For client-side encryption, common options include CryptoJS (a JavaScript library) and the Web Crypto API.</li> <li>For enhanced security, we chose to implement client-side key generation, as it enables true End-to-End Encryption (E2EE) \u2014 ensuring that private keys never leave the user\u2019s device. The Web Crypto API supports this approach by providing native, secure methods for AES and RSA key generation, encryption, and decryption directly within the browser.</li> </ul>"},{"location":"cryptography_algorithms/#after-understanding-the-algorithms-that-we-will-be-using-lets-jump-to-its-implementation-using-web-crypto-api","title":"After understanding the Algorithms that we will be using, let's Jump to it's implementation using Web Crypto API.","text":"<p>[[Hybrid Encryption]] </p>"},{"location":"cryptography_algorithms/aes/","title":"AES","text":""},{"location":"cryptography_algorithms/aes/#introduction","title":"INTRODUCTION","text":"<ul> <li>AES is a symmetric cipher, meaning it uses a single, shared secret key for both encryption and decryption. This makes it extremely fast and efficient, which is crucial for encrypting large amounts of data, like the stream of messages in a chat application.</li> </ul>"},{"location":"cryptography_algorithms/aes/#encryption","title":"ENCRYPTION","text":"<p>The Advanced Encryption Standard (AES) is a symmetric block cipher that transforms data using repeated cycles, or rounds.</p> <ol> <li> <p>Block and Key Structure: AES encrypts data in fixed 128-bit blocks (represented as a 4\u00d74 state matrix) using a secret Cipher Key that can be 128, 192, or 256 bits long. The key length determines the number of rounds (Nr\u200b) applied.     We will be using AES-256, with Mode GCM as it provides with Authentication tag, so if message is tampered we would know, and key size is 256 for improved security.</p> </li> <li> <p>Rounds of Transformation: After an initial AddRoundKey operation, the core encryption process repeats Nr\u200b times (e.g., 10, 12, or 14 rounds). Each of the first Nr\u200b\u22121 rounds consists of four byte-oriented transformations:</p> <ul> <li> <p>SubBytes(): Non-linear byte substitution using a lookup table (S-box).</p> </li> <li> <p>ShiftRows(): Cyclical shifting of the rows of the state matrix.</p> </li> <li> <p>MixColumns(): A matrix multiplication that mixes bytes within each column.</p> </li> <li> <p>AddRoundKey(): XORing the state matrix with a unique Round Key (derived from the main Cipher Key).</p> </li> </ul> </li> <li> <p>Final Round Difference: The very last round (the Nr\u200b-th round) is slightly different, as the MixColumns() transformation is omitted to maintain the mathematical symmetry necessary for successful decryption.</p> </li> </ol>"},{"location":"cryptography_algorithms/aes/#decryption","title":"DECRYPTION","text":"<p>The AES decryption process is the exact inverse of the encryption process, using the same secret key but applying the transformations in reverse order.</p> <ol> <li> <p>Inverse Rounds: Decryption also repeats the process Nr\u200b times (matching the key length). The difference is that the order of the transformations is reversed, and the inverse of each transformation is used (e.g., InvShiftRows(), InvSubBytes()).</p> </li> <li> <p>Inverse Transformations: In most of the rounds, the transformations are applied in this order:</p> <ul> <li> <p>InvShiftRows(): Cyclical right shifting of the rows.</p> </li> <li> <p>InvSubBytes(): Non-linear byte substitution using the inverse substitution table (InvS-box).</p> </li> <li> <p>InvMixColumns(): The matrix multiplication is performed using the inverse matrix.</p> </li> <li> <p>AddRoundKey(): The state is XORed with the Round Key, which is an operation that serves as its own inverse.</p> </li> </ul> </li> <li> <p>Key Scheduling: The Round Keys (derived from the main Cipher Key) are used in the reverse order compared to encryption. The key for the last encryption round is the first one used in decryption, and so on.</p> </li> <li> <p>Final Decryption Step: Just as the final encryption round omitted MixColumns(), the final decryption round omits InvMixColumns() to complete the successful reversal of the process, yielding the original 128-bit plaintext block.</p> </li> </ol>"},{"location":"cryptography_algorithms/aes/#iv-initialised-vector","title":"IV (Initialised Vector)","text":"<ul> <li>An IV is a random or pseudo-random value that is used alongside the encryption key when encrypting data.The IV ensures that even if the same plaintext is encrypted multiple times with the same key, the ciphertexts will be different, thus preventing pattern leakage.A new, random IV is generated for each message encrypted with AES</li> </ul>"},{"location":"cryptography_algorithms/rsa/","title":"RSA","text":""},{"location":"cryptography_algorithms/rsa/#introduction","title":"INTRODUCTION","text":"<p>RSA Algorithm is based on factorisation of large number and modular arithmetic for encrypting and decrypting data.  It consists of three main steps : 1. Key Generation  2. Encryption  3. Decryption </p>"},{"location":"cryptography_algorithms/rsa/#steps","title":"STEPS","text":""},{"location":"cryptography_algorithms/rsa/#1-key-generation","title":"1. KEY GENERATION","text":""},{"location":"cryptography_algorithms/rsa/#1-the-secret-foundation-choosing-primes","title":"1. The Secret Foundation (Choosing Primes)","text":"<p>The process starts with two numbers that must be kept secret:</p> <ul> <li>Choose Two Large Prime Numbers (p and q): These are the secret base of the entire system.</li> </ul>"},{"location":"cryptography_algorithms/rsa/#2-the-shared-modulus-n","title":"2. The Shared Modulus (n)","text":"<p>This number forms a part of both keys and is public knowledge.</p> <ul> <li> <p>Calculate the Modulus (n): Multiply the two secret primes together: n=p\u00d7q.</p> </li> <li> <p>Role of n: This large number is what makes the encryption secure. An attacker would need to factor n back into p and q to break the system, which is computationally infeasible for large numbers.</p> </li> </ul>"},{"location":"cryptography_algorithms/rsa/#3-the-exponents-e-and-d","title":"3. The Exponents (e and d)","text":"<p>This step creates the encryption (e) and decryption (d) exponents. These two numbers are designed to be inverses of each other under a specific secret mathematical condition.</p> <ul> <li>Choose the Public Exponent (e): Select a small, common number (e). This number is chosen based on a specific property with the secret primes (p and q) that ensures the subsequent calculation of d is possible.    </li> <li>Calculate the Private Exponent (d): Calculate d using a special mathematical formula that involves p and q and the public exponent e.</li> <li>The Key Relationship: d is the number that completely reverses the mathematical operation performed by e. It works because it satisfies a required modular arithmetic property related to the prime factors p and q.</li> <li>The requirement: The calculation must ensure that Decryption (d) is the modular inverse of Encryption (e).</li> </ul>"},{"location":"cryptography_algorithms/rsa/#final-keys","title":"Final Keys","text":"<p>Once the steps are complete, the keys are defined:</p> <ul> <li>Public Key (Shared with the World): (n,e)</li> <li>Private Key (Kept Secret): (n,d)</li> </ul> <p>Now these complex maths that goes behind is already done by Web Crypto API's functions and we would use them readily to make our life a little easier.</p>"},{"location":"cryptography_algorithms/rsa/#2encryption","title":"2.ENCRYPTION","text":"<ul> <li>When you encrypt data with a Public Key (n,e), the message (M) is first converted to a number. That number is raised to the power of the public exponent (e) and then the remainder is taken by the modulus (n). The result is the unreadable Ciphertext (C).<pre><code>                Ciphertext\u00a0(C) = M^e(modn)\n</code></pre> </li> </ul>"},{"location":"cryptography_algorithms/rsa/#3-decryption","title":"3. DECRYPTION","text":"<ul> <li>For decryption, the we uses  Private Key (n,d). we raise the ciphertext number (C) to the power of their private exponent (d) and take the remainder when divided by the modulus (n). This final number is the original message (M), which is then converted back to readable text.<pre><code>                Original\u00a0Message\u00a0(M) = C^d(modn)\n</code></pre> </li> </ul>"},{"location":"cryptography_algorithms/rsa/#why-secure","title":"WHY SECURE ?","text":"<ul> <li>RSA's security is based on the Factoring Problem: it's trivial to multiply two massive secret prime numbers (p and q) to get a large public modulus (n). However, to break the encryption and find the secret key, an attacker must reverse this process by factoring n back into p and q. For the key sizes used today, this task is so computationally intensive that it is practically impossible with current technology.</li> </ul>"}]}