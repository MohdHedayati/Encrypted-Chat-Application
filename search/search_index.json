{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Secure Chat App Documentation","text":"<p>Welcome to the documentation for the Secure Chat App, this is a comprehensive guide covering the project's architecture, security features, and implementation details.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Project Overview</li> <li>WebSockets</li> <li>Cryptography Algorithms<ul> <li>RSA</li> <li>AES</li> </ul> </li> <li>Hybrid Encryption</li> <li>Mini Projects</li> <li>Future Scope</li> <li>Conclusion</li> </ol>"},{"location":"hybrid_encryption/","title":"Hybrid Encryption","text":"<p>Now that we understand the fundamentals of Asymmetric (RSA) and Symmetric (AES) encryption algorithms, we can proceed with their implementation using the browser's built-in Web Crypto API.</p> <p>Let us first understand the need for Hybrid Encryption </p> <ul> <li> <p>Key Distribution Challenge: Symmetric AES requires both users to have the same secret key. Since users can't meet to exchange it, RSA is necessary to securely transmit that secret key across the internet.</p> </li> <li> <p>Performance Optimisation: The slow, computation-heavy RSA is used only once for the initial key delivery, ensuring the fast, efficient AES is reserved for the bulk of high-speed message transfer.</p> </li> <li> <p>Speed for Data (AES Strength): AES is vastly faster than RSA. This speed is essential for quickly encrypting the large volume of data (every chat message) required for a responsive user experience.</p> </li> <li> <p>Complete Confidentiality: Using the RSA-secured channel to deliver the AES key guarantees that the Session Key is known only to the two communicating parties, achieving true end-to-end confidentiality. </p> </li> <li> <p>Symmetric Encryption: The sender first uses a fast common Key (AES) to encrypt the Plaintext Message into Ciphertext.</p> </li> <li> <p>Asymmetric Key Transport: The sender then uses the recipient's Public Key (RSA) to securely encrypt and transport that small common Key alongside the ciphertext.</p> </li> <li> <p>Two-Step Decryption: The recipient first uses their secret Private Key (RSA) to retrieve the Session Key, which is then used to decrypt the Ciphertext back into the original message.</p> </li> </ul> <p>Web Cypto API's has functions that do this job for us : 1. Generate keys (Sender side)</p> <pre><code>export async function generateRSAKeyPair() {  \n    try {  \n        const keyPair = await window.crypto.subtle.generateKey(  \n            {  \n                name: \"RSA-OAEP\",  \n                modulusLength: 2048,  // Key size  \n                publicExponent: new Uint8Array([1, 0, 1]),  \n                hash: \"SHA-256\"  \n            },  \n            true,  // Public key is extractable  \n            [\"encrypt\", \"decrypt\"]  // Key usages  \n        );  \n\n        return keyPair;  // publicKey,privateKey  \n    } catch (error) {  \n        console.error(\"Error generating RSA key pair:\", error);  \n        throw error;  \n    }  \n}\n</code></pre> <ul> <li> <p>This function gives us the KeyPair(Private and Public key) by just specifying name of the mode (here RSA-OAEP) and we simply return it.</p> </li> <li> <p>Encrypt AES key using RSA public key(Sender side)</p> </li> </ul> <pre><code>export async function wrapAESKeyWithRSA(aesKey, receiverPublicKey) {  \n    try {  \n        // Export AES key to raw format  \n        const aesKeyRaw = await window.crypto.subtle.exportKey(\"raw\", aesKey);  \n\n        // Encrypt with RSA public key  \n        const wrappedKey = await window.crypto.subtle.encrypt(  \n            {  \n                name: \"RSA-OAEP\"  \n            },  \n            receiverPublicKey,  \n            aesKeyRaw  \n        );  \n\n        return arrayBufferToBase64(wrappedKey);  \n    } catch (error) {  \n        console.error(\"Error wrapping AES key:\", error);  \n        throw error;  \n    }  \n}\n</code></pre> <ul> <li> <p>For encrypting the AES Key we firstly convert it to Raw format(binary) and then encrypt it with receiver's Public Key.</p> </li> <li> <p>Decrypt AES key using RSA private key(Receiver side)</p> <ul> <li>This occurs after the message has been routed by the server to the receiver.</li> </ul> </li> </ul> <pre><code>export async function unwrapAESKeyWithRSA(wrappedKeyBase64, privateKey) {  \n    try {  \n        const wrappedKey = base64ToArrayBuffer(wrappedKeyBase64);  \n        const aesKeyRawBuffer = await window.crypto.subtle.decrypt(  \n            {  \n                name: \"RSA-OAEP\"  \n            },  \n            privateKey,  \n            wrappedKey  \n        );  \n            // After decrypting,must import the raw buffer back into a CryptoKey              object  \n        const aesKey = await window.crypto.subtle.importKey(  \n            \"raw\", // Format of the key to import  \n            aesKeyRawBuffer,  \n            {  \n                name: \"AES-GCM\",  \n                length: 256  \n            },  \n            true, // Extractable  \n            [\"encrypt\", \"decrypt\"]  \n        );  \n\n        return aesKey;  \n    } catch (error) {  \n        console.error(\"Error unwrapping AES key:\", error);  \n        throw error;  \n    }  \n}\n</code></pre> <ul> <li>Encrypted AES key is base64 encoded as needed for transmission and after transforming  it into Raw format, we decrypt it using Receiver's Private Key and finally we convert it into CryptoKey format using the Import Key function.</li> </ul>"},{"location":"hybrid_encryption/#we-saw-key-generation-encryption-and-decryption-for-rsa-similarly-we-can-do-for-aes","title":"We saw Key Generation, Encryption and Decryption for RSA  similarly we can do for AES.","text":""},{"location":"overview/","title":"Project Overview","text":""},{"location":"overview/#what-is-cryptography","title":"What is Cryptography","text":"<p>Cryptography is the practice and study of techniques for secure communication in the presence of adversarial behaviour. It involves transforming readable data (plain text) into an unreadable format (cipher text) and back again</p> <p>Our Chat App focuses on user's Privacy and confidentiality of Data, for that we use Two Cryptography Algorithms.  - RSA (Rivest-Shamir-Adleman) - AES (Advance Encryption Standard)</p>"},{"location":"overview/#need-for-cryptography","title":"Need for Cryptography","text":"<p>In a chat application, cryptography is essential to guarantee:</p> <ul> <li>Confidentiality<ul> <li>Messages are kept secret. Only the intended recipient can read the content, even if a third party (like the server or an attacker) intercepts the data.</li> </ul> </li> <li>Integrity<ul> <li>Ensures the message hasn't been altered during transmission.</li> </ul> </li> <li>Authentication<ul> <li>Verifies that the sender is who they claim to be.</li> </ul> </li> </ul>"},{"location":"overview/#implementation","title":"Implementation","text":""},{"location":"overview/#1-rsa","title":"1. [[RSA]]","text":"<ul> <li>Rivest-Shamir-Adleman (RSA) Algorithm is an * asymmetric or * public-key cryptography algorithm which means it works with two different keys:  Public Key and * Private Key.</li> </ul>"},{"location":"overview/#2-aes","title":"2. [[AES]]","text":"<ul> <li>Advanced Encryption Standard (AES) is an symmetric cryptography*  algorithm used to secure data using a single key for both Encryption and Decryption.</li> </ul>"},{"location":"overview/#web-crypto-api","title":"Web Crypto API","text":"<ul> <li>There are several libraries and frameworks available in Java for implementing cryptography, such as the Java Cryptography Architecture (JCA), which provides high-level APIs that abstract the low-level details of algorithms like AES and RSA.  </li> <li>For client-side encryption, common options include CryptoJS (a JavaScript library) and the Web Crypto API.</li> <li>For enhanced security, we chose to implement client-side key generation, as it enables true End-to-End Encryption (E2EE) \u2014 ensuring that private keys never leave the user\u2019s device. The Web Crypto API supports this approach by providing native, secure methods for AES and RSA key generation, encryption, and decryption directly within the browser.</li> </ul>"},{"location":"overview/#after-understanding-the-algorithms-that-we-will-be-using-lets-jump-to-its-implementation-using-web-crypto-api","title":"After understanding the Algorithms that we will be using, let's Jump to it's implementation using Web Crypto API.","text":"<p>[[Hybrid Encryption]] </p>"},{"location":"websockets/","title":"WebSockets in the Secure Chat App","text":"<p>WebSockets are a foundational technology for this project, enabling the real-time, bidirectional communication that is essential for a modern chat application.</p>"},{"location":"websockets/#what-are-websockets","title":"What are WebSockets?","text":"<p>A WebSocket is a communication protocol that provides a full-duplex, persistent connection between a client (like a user's browser) and a server.</p> <p>Think of traditional HTTP as sending letters. The client sends a request (a letter), and the server sends a response (a letter back). The conversation is a series of separate exchanges. A WebSocket, on the other hand, is like a telephone call. The client \"calls\" the server once to open a connection, and that line stays open, allowing both sides to talk freely and instantly until one of them hangs up.</p>"},{"location":"websockets/#why-use-websockets-for-a-chat-application","title":"Why Use WebSockets for a Chat Application?","text":"<p>Using WebSockets is critical for creating a responsive and seamless user experience.</p> <ul> <li>Low Latency: As soon as a message is sent, it's pushed through the open connection to the recipient almost instantly. There's no need for the client to constantly ask the server, \"Are there any new messages?\"</li> <li>Full-Duplex Communication: Data can flow in both directions at the same time. The server can push messages to the client at any moment, which is perfect for receiving new messages, typing indicators, and presence updates (e.g., online status).</li> <li>Efficiency: After the initial connection (the \"handshake\"), the data frames sent back and forth have very little overhead compared to the bulky headers of HTTP requests. This saves bandwidth and improves performance.</li> </ul>"},{"location":"websockets/#securing-websockets-wss","title":"Securing WebSockets (WSS)","text":"<p>Given the application's focus on security, all WebSocket connections are established using the Secure WebSocket protocol (<code>wss://</code>).</p> <p><code>WSS</code> is to <code>WS</code> what <code>HTTPS</code> is to <code>HTTP</code>. It means that the WebSocket connection is layered on top of a Transport Layer Security (TLS) tunnel. The initial handshake is done over HTTPS, and all subsequent WebSocket data is automatically encrypted by the same TLS layer that secures the rest of the application's traffic.</p> <p>This prevents eavesdropping and man-in-the-middle (MITM) attacks on the communication channel between the client and the server. It secures the \"pipe,\" while the End-to-End Encryption (E2EE) secures the message inside the pipe.</p>"},{"location":"websockets/#implementation-in-this-project","title":"Implementation in This Project","text":"<p>In our architecture, the Spring Boot backend exposes a WebSocket endpoint. The React frontend client initiates a connection to this endpoint. Once the secure handshake is complete, this persistent connection is used to:</p> <ol> <li>Send new chat messages from the client to the server.</li> <li>Push incoming messages from the server to the correct recipient client in real time.</li> <li>Transmit real-time events like typing notifications.</li> </ol>"},{"location":"cryptography_algorithms/aes/","title":"AES","text":""},{"location":"cryptography_algorithms/aes/#introduction","title":"INTRODUCTION","text":"<ul> <li>AES is a symmetric cipher, meaning it uses a single, shared secret key for both encryption and decryption. This makes it extremely fast and efficient, which is crucial for encrypting large amounts of data, like the stream of messages in a chat application.</li> </ul>"},{"location":"cryptography_algorithms/aes/#encryption","title":"ENCRYPTION","text":"<p>The Advanced Encryption Standard (AES) is a symmetric block cipher that transforms data using repeated cycles, or rounds.</p> <ol> <li> <p>Block and Key Structure: AES encrypts data in fixed 128-bit blocks (represented as a 4\u00d74 state matrix) using a secret Cipher Key that can be 128, 192, or 256 bits long. The key length determines the number of rounds (Nr\u200b) applied.     We will be using AES-256, with Mode GCM as it provides with Authentication tag, so if message is tampered we would know, and key size is 256 for improved security.</p> </li> <li> <p>Rounds of Transformation: After an initial AddRoundKey operation, the core encryption process repeats Nr\u200b times (e.g., 10, 12, or 14 rounds). Each of the first Nr\u200b\u22121 rounds consists of four byte-oriented transformations:</p> <ul> <li> <p>SubBytes(): Non-linear byte substitution using a lookup table (S-box).</p> </li> <li> <p>ShiftRows(): Cyclical shifting of the rows of the state matrix.</p> </li> <li> <p>MixColumns(): A matrix multiplication that mixes bytes within each column.</p> </li> <li> <p>AddRoundKey(): XORing the state matrix with a unique Round Key (derived from the main Cipher Key).</p> </li> </ul> </li> <li> <p>Final Round Difference: The very last round (the Nr\u200b-th round) is slightly different, as the MixColumns() transformation is omitted to maintain the mathematical symmetry necessary for successful decryption.</p> </li> </ol>"},{"location":"cryptography_algorithms/aes/#decryption","title":"DECRYPTION","text":"<p>The AES decryption process is the exact inverse of the encryption process, using the same secret key but applying the transformations in reverse order.</p> <ol> <li> <p>Inverse Rounds: Decryption also repeats the process Nr\u200b times (matching the key length). The difference is that the order of the transformations is reversed, and the inverse of each transformation is used (e.g., InvShiftRows(), InvSubBytes()).</p> </li> <li> <p>Inverse Transformations: In most of the rounds, the transformations are applied in this order:</p> <ul> <li> <p>InvShiftRows(): Cyclical right shifting of the rows.</p> </li> <li> <p>InvSubBytes(): Non-linear byte substitution using the inverse substitution table (InvS-box).</p> </li> <li> <p>InvMixColumns(): The matrix multiplication is performed using the inverse matrix.</p> </li> <li> <p>AddRoundKey(): The state is XORed with the Round Key, which is an operation that serves as its own inverse.</p> </li> </ul> </li> <li> <p>Key Scheduling: The Round Keys (derived from the main Cipher Key) are used in the reverse order compared to encryption. The key for the last encryption round is the first one used in decryption, and so on.</p> </li> <li> <p>Final Decryption Step: Just as the final encryption round omitted MixColumns(), the final decryption round omits InvMixColumns() to complete the successful reversal of the process, yielding the original 128-bit plaintext block.</p> </li> </ol>"},{"location":"cryptography_algorithms/aes/#iv-initialised-vector","title":"IV (Initialised Vector)","text":"<ul> <li>An IV is a random or pseudo-random value that is used alongside the encryption key when encrypting data.The IV ensures that even if the same plaintext is encrypted multiple times with the same key, the ciphertexts will be different, thus preventing pattern leakage.A new, random IV is generated for each message encrypted with AES</li> </ul>"},{"location":"cryptography_algorithms/rsa/","title":"RSA","text":""},{"location":"cryptography_algorithms/rsa/#introduction","title":"INTRODUCTION","text":"<p>RSA Algorithm is based on factorisation of large number and modular arithmetic for encrypting and decrypting data.  It consists of three main steps : 1. Key Generation  2. Encryption  3. Decryption </p>"},{"location":"cryptography_algorithms/rsa/#steps","title":"STEPS","text":""},{"location":"cryptography_algorithms/rsa/#1-key-generation","title":"1. KEY GENERATION","text":""},{"location":"cryptography_algorithms/rsa/#1-the-secret-foundation-choosing-primes","title":"1. The Secret Foundation (Choosing Primes)","text":"<p>The process starts with two numbers that must be kept secret:</p> <ul> <li>Choose Two Large Prime Numbers (p and q): These are the secret base of the entire system.</li> </ul>"},{"location":"cryptography_algorithms/rsa/#2-the-shared-modulus-n","title":"2. The Shared Modulus (n)","text":"<p>This number forms a part of both keys and is public knowledge.</p> <ul> <li> <p>Calculate the Modulus (n): Multiply the two secret primes together: n=p\u00d7q.</p> </li> <li> <p>Role of n: This large number is what makes the encryption secure. An attacker would need to factor n back into p and q to break the system, which is computationally infeasible for large numbers.</p> </li> </ul>"},{"location":"cryptography_algorithms/rsa/#3-the-exponents-e-and-d","title":"3. The Exponents (e and d)","text":"<p>This step creates the encryption (e) and decryption (d) exponents. These two numbers are designed to be inverses of each other under a specific secret mathematical condition.</p> <ul> <li>Choose the Public Exponent (e): Select a small, common number (e). This number is chosen based on a specific property with the secret primes (p and q) that ensures the subsequent calculation of d is possible.    </li> <li>Calculate the Private Exponent (d): Calculate d using a special mathematical formula that involves p and q and the public exponent e.</li> <li>The Key Relationship: d is the number that completely reverses the mathematical operation performed by e. It works because it satisfies a required modular arithmetic property related to the prime factors p and q.</li> <li>The requirement: The calculation must ensure that Decryption (d) is the modular inverse of Encryption (e).</li> </ul>"},{"location":"cryptography_algorithms/rsa/#final-keys","title":"Final Keys","text":"<p>Once the steps are complete, the keys are defined:</p> <ul> <li>Public Key (Shared with the World): (n,e)</li> <li>Private Key (Kept Secret): (n,d)</li> </ul> <p>Now these complex maths that goes behind is already done by Web Crypto API's functions and we would use them readily to make our life a little easier.</p>"},{"location":"cryptography_algorithms/rsa/#2encryption","title":"2.ENCRYPTION","text":"<ul> <li>When you encrypt data with a Public Key (n,e), the message (M) is first converted to a number. That number is raised to the power of the public exponent (e) and then the remainder is taken by the modulus (n). The result is the unreadable Ciphertext (C).<pre><code>                Ciphertext\u00a0(C) = M^e(modn)\n</code></pre> </li> </ul>"},{"location":"cryptography_algorithms/rsa/#3-decryption","title":"3. DECRYPTION","text":"<ul> <li>For decryption, the we uses  Private Key (n,d). we raise the ciphertext number (C) to the power of their private exponent (d) and take the remainder when divided by the modulus (n). This final number is the original message (M), which is then converted back to readable text.<pre><code>                Original\u00a0Message\u00a0(M) = C^d(modn)\n</code></pre> </li> </ul>"},{"location":"cryptography_algorithms/rsa/#why-secure","title":"WHY SECURE ?","text":"<ul> <li>RSA's security is based on the Factoring Problem: it's trivial to multiply two massive secret prime numbers (p and q) to get a large public modulus (n). However, to break the encryption and find the secret key, an attacker must reverse this process by factoring n back into p and q. For the key sizes used today, this task is so computationally intensive that it is practically impossible with current technology.</li> </ul>"}]}